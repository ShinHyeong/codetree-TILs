N = int(input())
numbers = list(map(int, input().split()))

# Please write your code here.

## 요구사항 분석
# 묶음 합이 짝홀이 번갈아 나게 묶어라.
# 최대 묶음 수를 구하라
# 주어진 순서랑 상관없이 묶음 만들어도 됨

## 예제분석
# 1,3,9,7,5,11,3
# 4 | 21 | 14 (->3개)
# 4 | 9 | 12 | 11 | 3 (짝홀짝홀홀 -> x)

# 11 2 17 13 1 15 3
# 11 2 17 | 13 | 1 15 | 3 -> 30 | 13 | 16 | 3 -> 묶음 수 : 4
# 2 | 11 | 17 13 | 1 | 15 3 -> 순서바꾸면 묶음 수 : 5 짝홀짝홀짝

## 로직 설정
# 나올 수 있는 수의 갯수 : 2개 ~ 100개
# 나올 수 있는 수 : 1~100
# 묶음 당 원소 갯수가 최소가 되어야 묶음수가 최대가 됨
# 홀+홀 = 짝 (->홀수갯수: 2)
# 홀+짝 = 홀 (->홀수갯수: 1)
# 짝+짝 = 짝 (->홀수갯수: 0)
# 홀+홀+홀 = 홀 (->홀수갯수: 3)
# 홀+홀+짝 = 짝 (->홀수갯수: 2)
# 홀+짝+짝 = 홀 (->홀수갯수: 1)
# 짝+짝+짝 = 짝 (->홀수갯수: 0)
# 홀+홀+홀+홀=짝 (->홀수갯수: 4)
# 홀+홀+홀+홀+홀 = 홀 (->홀수갯수: 5)
# 이처럼 홀수의 갯수가 한 묶음에 홀수개 있으면 홀수가 나오고, 짝수개 있으면 짝수가 나온다. 
# 짝홀짝홀/짝홀짝홀짝은 되지만 짝홀홀은 되지않는다. 
# 즉, 짝수는 홀수의 갯수또는 홀수+1개만큼 있어야한다. 홀수는 짝수의 갯수 또는 짝수-1개만큼 있어야한다.
# 

# 1,3,9,7,5,11,3
# 짝,홀 갯수 : (0,7)
# 홀2를 하나씩 만든다
# -> (1,5) 조건 충족x
# -> (2,3) 조건 충족x
# -> (3,1) 조건 충족x
# 홀수가 홀수개라면 이를 묶는 것도 충족못하는지 확인한다
# -> (2,1) 충족 o


# 11 2 17 13 1 15 3
# 짝,홀 갯수 : (1,6)
# 홀2를 하나씩 만든다 
# -> (2,4) 조건 충족x
# -> (3,2) 조건 충족O

even_cnt, odd_cnt = 0,0 #짝,홀 갯수
for num in numbers:
    if num%2==0:
        even_cnt+=1
    else:
        odd_cnt+=1
#print(even_cnt, odd_cnt)

def is_answer():
    return even_cnt==odd_cnt+1 or even_cnt==odd_cnt

answer = 0

while True:
    if odd_cnt == 0: #종료조건
        break

    if odd_cnt >= 2:
        even_cnt += 1
        odd_cnt -= 2
        if is_answer():
            answer = even_cnt+odd_cnt
            break
        if odd_cnt%2==1:
            odd_cnt-=2
            if is_answer():
                answer = even_cnt+odd_cnt
                break


print(answer)


